package org.example.pmas.repository;

import org.example.pmas.exception.ConnectionException;
import org.example.pmas.model.Task;
import org.example.pmas.model.rowMapper.TaskRowMapper;
import org.example.pmas.repository.Interfaces.ITaskRepository;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;

import java.sql.PreparedStatement;

import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Statement;
import java.util.*;

@Repository
public class TaskRepository implements ITaskRepository {
    private final JdbcTemplate jdbcTemplate;


    public TaskRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional
    @Override
    public Task create(Task task) {
        String sql = "INSERT INTO tasks (name, description, timeBudget, timeTaken, completed, deadline, subprojectID) " + "VALUES (?, ?, ?, ?, ?, ?, ?)";

        // Object for id
        KeyHolder keyHolder = new GeneratedKeyHolder();

        try {
            jdbcTemplate.update(connection -> {
                PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
                ps.setString(1, task.getName());
                ps.setString(2, task.getDescription());
                ps.setDouble(3, task.getTimeBudget());
                ps.setDouble(4, task.getTimeTaken());
                ps.setBoolean(5, task.isCompleted());
                ps.setObject(6, task.getDeadline());
                ps.setInt(7, task.getSubProject().getId());
                return ps;
            }, keyHolder);
        } catch (DataAccessException e) {
            throw new ConnectionException("Database fejl: kunne ikke indsætte opgaven.", e);
        }
        // Collects autogenerated id from the database if any
        Number key = keyHolder.getKey();
        // If no id created
        if (key == null) return null;

        // Insert id
        task.setId(key.intValue());

        return task;
    }

    @Transactional
    @Override
    public List<Task> readAll() {
        String sql = "SELECT " +
                "t.*, " +
                "sp.id as subproject_id, " +
                "sp.name as subproject_name, " +
                "GROUP_CONCAT(u.id SEPARATOR ',') AS user_ids, " +
                "GROUP_CONCAT(u.name SEPARATOR ',') AS user_names " +
                "FROM tasks t " +
                "LEFT JOIN usertasks ut ON t.id = ut.taskid " +
                "LEFT JOIN users u ON ut.userid = u.id " +
                "LEFT JOIN subprojects sp ON t.subprojectID = sp.id " +
                "GROUP BY t.id";

        try {
            return jdbcTemplate.query(sql, new TaskRowMapper());
        } catch (DataAccessException e) {
            throw new ConnectionException("Database fejl: kunne ikke hente alle opgaver.", e);
        }
    }

    @Transactional
    @Override
    public Task readSelected(int id) {
        String sql = " SELECT " +
                "t.*, " +
                "sp.id as subproject_id, " +
                "sp.name as subproject_name, " +
                "GROUP_CONCAT(u.id SEPARATOR ',') as user_ids, " +
                "GROUP_CONCAT(u.name SEPARATOR ',') as user_names " +
                "FROM tasks t " +
                "LEFT JOIN usertasks ut ON t.id = ut.taskid " +
                "LEFT JOIN users u ON ut.userid = u.id " +
                "LEFT JOIN subprojects sp ON sp.id = t.id " +
                "WHERE t.id = ? " + "GROUP BY t.id";

        List<Task> task = new ArrayList<>();
        try {
            task = jdbcTemplate.query(sql, new TaskRowMapper(), id);
        } catch (DataAccessException e) {
            throw new ConnectionException("Database fejl: kunne ikke hente opgaven.", e);
        }
        return task.isEmpty()
                ? null
                : task.getFirst();
    }

    @Transactional
    @Override
    public boolean delete(int id) {
        String sql = "DELETE FROM tasks WHERE id = ?";

        try {
            return jdbcTemplate.update(sql, id) > 0;
        } catch (DataAccessException e) {
            throw new ConnectionException("Fejl: kunne ikke slette opgaven.", e);
        }
    }

    @Transactional
    @Override
    public boolean update(Task newObject) {
        String sql = "UPDATE tasks SET " +
                "name = ?, " +
                "description = ?, " +
                "timeBudget = ?, " +
                "timeTaken = ?, " +
                "completed = ?, " +
                "deadline = ?, " +
                "subprojectID = ? " +
                "WHERE id = ?";

        try {
            return jdbcTemplate.update(sql,
                    newObject.getName(),
                    newObject.getDescription(),
                    newObject.getTimeBudget(),
                    newObject.getTimeTaken(),
                    newObject.isCompleted(),
                    newObject.getDeadline(),
                    newObject.getSubProject().getId(),
                    newObject.getId()) > 0;
        } catch (NullPointerException e) {
            throw new ConnectionException("Fejl: kunne ikke opdatere opgaven.");
        }
    }

    @Transactional
    @Override
    public boolean addUserToTask(int taskId, List<Integer> newUserIds) {
        // Fetch users for comparison
        List<Integer> currentUserIds = getCurrentUserIdsFromUserTasks(taskId);

        // Check differences for add or remove user from a task
        Set<Integer> toAdd = differenceOrEmpty(newUserIds, currentUserIds);
        Set<Integer> toRemove = differenceOrEmpty(currentUserIds, newUserIds);

        // Add/Remove if needed
        int added = addUsersToUserTasks(taskId, toAdd);
        int removed = removeUsersFromUserTasks(taskId, toRemove);

        return added == 0 && removed == 0;
    }

    private List<Integer> getCurrentUserIdsFromUserTasks(int taskId) {
        try {
            return jdbcTemplate.queryForList("SELECT userid FROM usertasks WHERE taskid = ?", Integer.class, taskId);
        } catch (DataAccessException e) {
            throw new ConnectionException("Fejl: kunne ikke hente brugerid'er til opgaven.", e);
        }
    }

    private int addUsersToUserTasks(int taskId, Set<Integer> userIds) {
        int count = 0;
        for (Integer userId : userIds) {
            try {
                jdbcTemplate.update("INSERT INTO usertasks (userid, taskid) " +
                                "VALUES (?, ?)",
                        userId,
                        taskId);
            } catch (DataAccessException e) {
                throw new ConnectionException("Fejl: kunne ikke indsætte brugerid'er til opgaven.", e);
            }
            count++;
        }

        return count;
    }

    // Removes users from
    private int removeUsersFromUserTasks(int taskId, Set<Integer> userIds) {
        int count = 0;
        for (Integer userId : userIds) {
            try {
                jdbcTemplate.update("DELETE FROM usertasks WHERE userid = ? AND taskid = ?",
                        userId,
                        taskId);
            } catch (DataAccessException e) {
                throw new ConnectionException("Fejl: kunne ikke fjerne brugerid'er fra opgaven.", e);
            }

            count++;
        }
        return count;
    }

    // if no users added to the list. it will throw and error.
    // this will avoid error
    private Set<Integer> differenceOrEmpty(List<Integer> baseList, List<Integer> subtractList) {
        if (subtractList == null) subtractList = Collections.emptyList();
        if (baseList == null) baseList = Collections.emptyList();

        Set<Integer> result = new HashSet<>(baseList);
        result.removeAll(subtractList);
        return result;
    }
}
