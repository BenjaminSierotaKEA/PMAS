package org.example.pmas.repository;

import org.example.pmas.exception.DatabaseException;
import org.example.pmas.model.Task;
import org.example.pmas.model.rowMapper.TaskRowMapper;
import org.example.pmas.repository.Interfaces.ITaskRepository;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;

import java.sql.PreparedStatement;

import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Statement;
import java.util.*;

@Repository
public class TaskRepository implements ITaskRepository {
    private final JdbcTemplate jdbcTemplate;


    public TaskRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional
    @Override
    public Task create(Task task) {
        String sql = "INSERT INTO tasks " +
                "(name, description, priorityLevel, timeBudget, timeTaken, completed, deadline, subprojectID) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";

        // Object for id
        KeyHolder keyHolder = new GeneratedKeyHolder();

        try {
            jdbcTemplate.update(connection -> {
                PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
                ps.setString(1, task.getName());
                ps.setString(2, task.getDescription());
                // Vi sætter priority til null ellers vil det crashe, når vi henter dem.
                ps.setString(3, task.getPriorityLevel() != null ? task.getPriorityLevel().name() : null);
                ps.setDouble(4, task.getTimeBudget());
                ps.setDouble(5, task.getTimeTaken());
                ps.setBoolean(6, task.isCompleted());
                ps.setObject(7, task.getDeadline());
                ps.setInt(8, task.getSubProject().getId());
                return ps;
            }, keyHolder);
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not insert task.", e);
        }
        // Collects autogenerated id from the database if any
        Number key = keyHolder.getKey();
        // If no id created
        if (key == null) return null;

        // Insert id
        task.setId(key.intValue());

        return task;
    }

    @Transactional
    @Override
    public List<Task> readAll() {
        String sql = "SELECT " +
                "t.*, " +
                "GROUP_CONCAT(u.id SEPARATOR ',') AS user_ids, " +
                "GROUP_CONCAT(u.name SEPARATOR ',') AS user_names " +
                "FROM tasks t " +
                "LEFT JOIN usertasks ut ON t.id = ut.taskid " +
                "LEFT JOIN users u ON ut.userid = u.id " +
                "LEFT JOIN subprojects sp ON t.subprojectID = sp.id " +
                "GROUP BY t.id";

        try {
            return jdbcTemplate.query(sql, new TaskRowMapper());
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not get all tasks.", e);
        }
    }

    @Transactional
    @Override
    public Task readSelected(int id) {
        String sql = "SELECT " +
                "t.*, " +
                "GROUP_CONCAT(u.id SEPARATOR ',') as user_ids, " +
                "GROUP_CONCAT(u.name SEPARATOR ',') as user_names " +
                "FROM tasks t " +
                "LEFT JOIN usertasks ut ON t.id = ut.taskid " +
                "LEFT JOIN users u ON ut.userid = u.id " +
                "LEFT JOIN subprojects sp ON sp.id = t.id " +
                "WHERE t.id = ? " +
                "GROUP BY t.id";

        List<Task> task;
        try {
            task = jdbcTemplate.query(sql, new TaskRowMapper(), id);
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not get the task.", e);
        }
        return task.isEmpty()
                ? null
                : task.getFirst();
    }

    @Transactional
    @Override
    public boolean delete(int id) {
        String sql = "DELETE FROM tasks WHERE id = ?";

        try {
            return jdbcTemplate.update(sql, id) > 0;
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not delete task.", e);
        }
    }

    @Transactional
    @Override
    public boolean update(Task newObject) {
        String sql = "UPDATE tasks SET " +
                "name = ?, " +
                "description = ?, " +
                "priorityLevel = ?, " +
                "timeBudget = ?, " +
                "timeTaken = ?, " +
                "completed = ?, " +
                "deadline = ?, " +
                "subprojectID = ? " +
                "WHERE id = ?";

        try {
            return jdbcTemplate.update(sql,
                    newObject.getName(),
                    newObject.getDescription(),
                    newObject.getPriorityLevel().name(),
                    newObject.getTimeBudget(),
                    newObject.getTimeTaken(),
                    newObject.isCompleted(),
                    newObject.getDeadline(),
                    newObject.getSubProject().getId(),
                    newObject.getId()) > 0;
        } catch (NullPointerException e) {
            throw new DatabaseException("Database error: could not update task.");
        }
    }

    @Transactional
    @Override
    public List<Integer> getCurrentUserIdsFromUserTasks(int taskId) {
        try {
            return jdbcTemplate.queryForList("SELECT userid " +
                            "FROM usertasks " +
                            "WHERE taskid = ?",
                    Integer.class,
                    taskId);
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not get userid for task.", e);
        }
    }

    @Transactional
    @Override
    public void addUsersToUserTasks(int taskId, Set<Integer> userIds) {
        for (Integer userId : userIds) {
            try {
                jdbcTemplate.update("INSERT INTO usertasks (userid, taskid) " +
                                "VALUES (?, ?)",
                        userId,
                        taskId);
            } catch (DataAccessException e) {
                throw new DatabaseException("Database error: could not insert userid associated with task.", e);
            }
        }
    }

    // Removes users from junction table
    @Transactional
    @Override
    public void removeUsersFromUserTasks(int taskId, Set<Integer> userIds) {
        for (Integer userId : userIds) {
            try {
                jdbcTemplate.update("DELETE FROM usertasks " +
                                "WHERE userid = ? AND taskid = ?",
                        userId,
                        taskId);
            } catch (DataAccessException e) {
                throw new DatabaseException("Database error: could not remove userid associated with task.", e);
            }
        }
    }

    @Transactional
    @Override
    public List<Task> getTasksBySubProjectID(int subprojectId) {
        String sql = "SELECT " +
                "t.*, " +
                "GROUP_CONCAT(u.id SEPARATOR ',') AS user_ids, " +
                "GROUP_CONCAT(u.name SEPARATOR ',') AS user_names " +
                "FROM tasks t " +
                "LEFT JOIN usertasks ut ON t.id = ut.taskid " +
                "LEFT JOIN users u ON ut.userid = u.id " +
                "LEFT JOIN subprojects sp ON t.subprojectID = sp.id " +
                "WHERE t.subProjectID = ? " +
                "GROUP BY t.id";
        try {
            return jdbcTemplate.query(sql,
                    new TaskRowMapper(),
                    subprojectId);
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not get task from subproject id.", e);
        }
    }

    @Transactional
    @Override
    public List<Task> findAllByUserId(int userId) {
        String sql = """
                 SELECT t.*,\s
                        GROUP_CONCAT(u.id) AS user_ids,\s
                        GROUP_CONCAT(u.name) AS user_names
                 FROM tasks t
                 JOIN usertasks ut ON t.id = ut.taskid
                 JOIN users u ON u.id = ut.userid
                 WHERE ut.userid = ?
                 GROUP BY t.id;
                
                """;

        try {
            return jdbcTemplate.query(sql, new TaskRowMapper(), userId);
        } catch (DataAccessException e) {
            throw new DatabaseException("Database error: could not get task from user id.", e);
        }
    }

}
